<!DOCTYPE html>
<html lang="da">

<head>
    <meta charset="UTF-8">
    <title>Fyn Vandkemi Stoftransport Kemidata</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/3.0.1/chartjs-plugin-annotation.min.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #f4f4f9;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        h3 {
            color: #005a9e;
            margin-top: 30px;
            font-size: 1.2em;
        }

        .controls-header {
            background: #e9ecef;
            padding: 20px;
            border-radius: 6px;
            display: flex;
            gap: 20px;
            align-items: flex-end;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
            color: #555;
        }

        input[type="date"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        button {
            padding: 10px 25px;
            background: #0078d4;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #005a9e;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-green {
            background: #28a745;
            margin-left: auto;
        }

        .btn-green:hover {
            background: #218838;
        }

        .btn-small {
            padding: 5px 15px;
            font-size: 12px;
            margin-right: 5px;
            background: #6c757d;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 3px;
        }

        .btn-small:hover {
            background: #5a6268;
        }

        .filter-section {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 6px;
            display: none;
            background: #fafafa;
            margin-top: 20px;
        }

        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .filter-links a {
            color: #0078d4;
            cursor: pointer;
            text-decoration: underline;
            margin-left: 15px;
            font-size: 13px;
        }

        .filter-box {
            max-height: 200px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 8px;
            border: 1px solid #eee;
            padding: 10px;
            background: #fff;
        }

        .filter-item {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-wrapper {
            overflow-x: auto;
            border: 1px solid #eee;
            margin-top: 15px;
            padding: 15px;
            background: #fff;
            border-radius: 4px;
        }

        .chart-container {
            position: relative;
            height: 450px;
            min-width: 100%;
        }

        #detailsSection {
            margin-top: 40px;
            display: none;
            border-top: 4px solid #0078d4;
            padding-top: 20px;
        }

        .details-info {
            margin-bottom: 15px;
            font-size: 14px;
        }

        .vanda-link {
            display: inline-block;
            margin-top: 5px;
            color: #fff;
            background-color: #28a745;
            padding: 5px 10px;
            text-decoration: none;
            border-radius: 3px;
            font-size: 12px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 13px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
            color: #333;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* KS Niveau farver i tabel */
        .ks-cell {
            font-weight: bold;
            text-align: center;
        }

        .ks-0 {
            background-color: #d4edda;
            color: #155724;
        }

        .ks-1 {
            background-color: #cce5ff;
            color: #004085;
        }

        .ks-2 {
            background-color: #fff3cd;
            color: #856404;
        }

        .ks-3 {
            background-color: #f8d7da;
            color: #721c24;
        }

        .ks-unknown {
            background-color: #f0f0f0;
            color: #666;
        }

        /* Legend dots */
        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
            font-size: 13px;
            color: #666;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        hr {
            margin: 40px 0;
            border: 0;
            border-top: 2px solid #eee;
        }

        #log {
            background: #222;
            color: #0f0;
            padding: 15px;
            margin-top: 30px;
            font-family: 'Consolas', monospace;
            height: 100px;
            overflow-y: auto;
            font-size: 12px;
            border-radius: 4px;
        }
    </style>
</head>

<body>

    <div class="container">
        <h2>Fyn Vandkemi Stoftransport Kemidata</h2>

        <div class="controls-header">
            <div class="control-group">
                <label for="startDate">Start Dato:</label>
                <input type="date" id="startDate" value="2026-01-01">
            </div>
            <div class="control-group">
                <label for="endDate">Slut Dato:</label>
                <input type="date" id="endDate" value="2026-01-17">
            </div>
            <button id="btnFetch" onclick="startAnalysis()">Hent Data</button>
            <button id="btnDownload" onclick="downloadRawData()" class="btn-green" disabled>Download Rådata
                (Zip)</button>
        </div>

        <h3>Antal Prøver pr Station</h3>
        <div class="chart-wrapper">
            <div class="chart-container" id="chartBox1">
                <canvas id="chartVisits"></canvas>
            </div>
        </div>

        <div id="filterContainer" class="filter-section">
            <div class="filter-header">
                <h3 style="margin:0;">2. Filter (Parametre)</h3>
                <div class="filter-links">
                    <button class="btn-small" onclick="updateScatterChart()">Opdater Graf</button>
                    <a onclick="toggleAllFilters(true)">Vælg alle</a>
                    <a onclick="toggleAllFilters(false)">Fravælg alle</a>
                </div>
            </div>
            <div id="filterList" class="filter-box"></div>
        </div>

        <hr>

        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3>3. Antal parametre pr. Prøve</h3>
            <button class="btn-small" onclick="if(chartParams) chartParams.resetZoom()">Nulstil Zoom ⟲</button>
        </div>
        <p style="font-size:13px; color:#666;">Klik på et punkt for at se tidsserie og tabel. Træk en boks for at zoome.</p>
        <div id="legendContainer" style="margin-bottom: 5px;"></div>

        <div class="chart-wrapper">
            <div class="chart-container" id="chartBox2">
                <canvas id="chartParams"></canvas>
            </div>
        </div>

        <div id="detailsSection">
            <h3>4. Detaljer for valgt prøve</h3>
            <div id="detailsInfo" class="details-info"></div>

            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:30px;">
                <h4 style="margin:0; color:#444;">Tidsserie for valgt station</h4>
                <button class="btn-small" onclick="resetZoomChart()">Nulstil Zoom ⟲</button>
            </div>
            <p style="font-size:12px; color:#666;">Marker et område med musen for at zoome ind.</p>

            <div class="chart-wrapper">
                <div class="chart-container" id="chartBox3">
                    <canvas id="chartTime"></canvas>
                </div>
            </div>

            <div style="max-height: 400px; overflow-y: auto;">
                <table id="detailsTable">
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Status</th>
                            <th>Værdi</th>
                            <th>Prøvetagning</th>
                            <th style="width:80px;">KS niveau</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div id="log">Klar...</div>
    </div>

    <script>
        const logDiv = document.getElementById('log');
        const btnFetch = document.getElementById('btnFetch');
        const btnDownload = document.getElementById('btnDownload');
        const filterContainer = document.getElementById('filterContainer');
        const filterListDiv = document.getElementById('filterList');
        const detailsSection = document.getElementById('detailsSection');
        const detailsTableBody = document.querySelector('#detailsTable tbody');
        const detailsInfo = document.getElementById('detailsInfo');
        const legendContainer = document.getElementById('legendContainer');

        let chartVisits = null;
        let chartParams = null;
        let chartTime = null;

        let structuredData = {};
        let stationHistory = {};
        let allParameters = new Set();
        let rawZipBlob = null;

        // Farve-definitioner for KS niveauer
        const ksColors = {
            0: 'rgba(46, 204, 113, 0.8)',   // Grøn
            1: 'rgba(52, 152, 219, 0.8)',   // Blå
            2: 'rgba(241, 196, 15, 0.8)',   // Gul
            3: 'rgba(231, 76, 60, 0.8)',    // Rød
            '-1': 'rgba(149, 165, 166, 0.8)' // Grå
        };

        function log(msg) {
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML = `[${time}] ${msg}<br>` + logDiv.innerHTML;
            console.log(msg);
        }

        async function startAnalysis() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            if (!startDate || !endDate) return alert("Angiv periode.");

            btnFetch.disabled = true;
            btnDownload.disabled = true;
            btnFetch.textContent = "Henter...";

            filterContainer.style.display = "none";
            detailsSection.style.display = "none";
            structuredData = {};
            stationHistory = {};
            allParameters.clear();

            const url = "https://kemidata.miljoeportal.dk/api/download";
            const payload = {
                "language": "da",
                "searchValues": ["Datamart Vandkemi Hydrometri"],
                "period": { "showLastResult": false, "fromDate": `${startDate}T00:00:00.000+01:00`, "toDate": `${endDate}T23:59:59.000+01:00` },
                "dataResponsibles": ["25798376"],
                "searchBy": "ExaminationTypes",
                "area": { "type": "Polygon", "geoJsonString": "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[548721.3371364629,6156252.700681684],[546256.3113745265,6146834.8744126195],[547376.7776299521,6132259.667091451],[557236.8806776978,6112527.078718175],[570234.2892406355,6097279.169520644],[592867.7076002337,6071716.4982189005],[617069.7787174279,6060953.268197114],[628498.5345227695,6103557.720366686],[627826.2547695141,6124635.712492685],[612812.0069468103,6160513.14589864],[589058.1223317864,6172173.311755576],[561494.6524483154,6165446.2929919595],[548721.3371364629,6156252.700681684]]]},\"properties\":null}]}" },
                "isDownloadAll": true,
                "sessionId": null,
                "localId": null
            };

            try {
                const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);

                const blob = await res.blob();
                if (blob.type.includes("json")) throw new Error("Server returnerede JSON");

                rawZipBlob = blob;
                btnDownload.disabled = false;

                log(`Hentet ${(blob.size / 1024 / 1024).toFixed(2)} MB.`);

                const zip = await JSZip.loadAsync(blob);
                const filename = Object.keys(zip.files)[0];
                const csvText = await zip.files[filename].async("string");

                processCSV(csvText);
            } catch (e) {
                log("Fejl: " + e.message);
            } finally {
                btnFetch.disabled = false;
                btnFetch.textContent = "Hent Data";
            }
        }

        function downloadRawData() {
            if (!rawZipBlob) return;
            const url = window.URL.createObjectURL(rawZipBlob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            const dato = new Date().toISOString().split('T')[0];
            a.download = `kemidata_${dato}.zip`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function processCSV(csv) {
            const lines = csv.split('\n');
            const separator = lines[0].includes('\t') ? '\t' : ';';
            const headers = lines[0].split(separator).map(h => h.trim());

            const idxStation = headers.indexOf("Stedtekst");
            const idxDate = headers.indexOf("Dato");
            const idxParam = headers.indexOf("Stofparameter");
            const idxLink = headers.indexOf("Link");
            const idxResult = headers.indexOf("Resultat");
            const idxQuality = headers.indexOf("Kvalitetsmærke");
            const idxSampling = headers.indexOf("Prøvetagning");

            if (idxStation < 0) return log("Mangler kolonner.");

            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(separator);
                if (row.length < idxStation) continue;

                const station = (row[idxStation] || "").replace(/"/g, '').trim();
                const rawDateStr = (row[idxDate] || "").trim();
                const param = (row[idxParam] || "").trim();

                let quality = -1;
                if (idxQuality > -1 && row[idxQuality]) {
                    const qStr = row[idxQuality].replace(/"/g, '').trim();
                    if (qStr !== "") quality = parseInt(qStr, 10);
                }

                let val = null;
                if (idxResult > -1 && row[idxResult]) {
                    val = parseFloat(row[idxResult].replace(',', '.'));
                }

                const samplingId = (idxSampling > -1 && row[idxSampling]) ? row[idxSampling].replace(/"/g, '').trim() : "";

                if (station && rawDateStr && param) {
                    const cleanDate = formatDateToISO(rawDateStr);

                    if (!structuredData[station]) structuredData[station] = {};
                    if (!structuredData[station][cleanDate]) {
                        structuredData[station][cleanDate] = {
                            params: [],
                            link: "",
                            values: {},
                            qualities: {},
                            samplingMap: {},
                            allSamplingIds: new Set()
                        };
                    }

                    structuredData[station][cleanDate].params.push(param);
                    if (val !== null && !isNaN(val)) {
                        structuredData[station][cleanDate].values[param] = val;
                    }

                    structuredData[station][cleanDate].qualities[param] = quality;
                    // Add to Set of IDs per parameter
                    if (samplingId) {
                        if (!structuredData[station][cleanDate].samplingMap[param]) {
                            structuredData[station][cleanDate].samplingMap[param] = new Set();
                        }
                        structuredData[station][cleanDate].samplingMap[param].add(samplingId);
                        structuredData[station][cleanDate].allSamplingIds.add(samplingId);
                    }

                    allParameters.add(param);
                    if (!structuredData[station][cleanDate].link && idxLink > -1 && row[idxLink]) {
                        structuredData[station][cleanDate].link = row[idxLink].replace(/"/g, '').trim();
                    }

                    if (val !== null && !isNaN(val)) {
                        if (!stationHistory[station]) stationHistory[station] = [];
                        stationHistory[station].push({
                            date: cleanDate,
                            param: param,
                            value: val,
                            quality: quality
                        });
                    }
                }
            }

            log(`Data parset.`);
            drawVisitsChart();
            buildFilterUI();
            updateScatterChart();
        }

        function formatDateToISO(dateStr) {
            let d = dateStr.split(/[ T]/)[0];
            const parts = d.split(/[\/\-\.]/);
            if (parts.length === 3) {
                if (parts[2].length === 4) {
                    return `${parts[2]}-${parts[1]}-${parts[0]}`;
                }
            }
            return d;
        }

        // --- CHARTS ---

        function drawVisitsChart() {
            const labels = Object.keys(structuredData).sort();
            const dataCounts = labels.map(station => Object.keys(structuredData[station]).length);
            const width = Math.max(100, labels.length * 30);
            document.getElementById('chartBox1').style.width = `${width}px`;

            const ctx = document.getElementById('chartVisits').getContext('2d');
            if (chartVisits) chartVisits.destroy();
            chartVisits = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{ label: 'Antal Prøver', data: dataCounts, backgroundColor: '#0078d4', borderRadius: 3 }]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { ticks: { autoSkip: false, maxRotation: 90 } } }, plugins: { legend: { display: false } } }
            });
        }

        function buildFilterUI() {
            filterListDiv.innerHTML = "";
            const sortedParams = Array.from(allParameters).sort();
            sortedParams.forEach(param => {
                const safeId = "chk_" + param.replace(/[^a-zA-Z0-9]/g, "_");
                const div = document.createElement("div");
                div.className = "filter-item";
                div.innerHTML = `<input type="checkbox" checked value="${param}" id="${safeId}"> <label for="${safeId}">${param}</label>`;
                filterListDiv.appendChild(div);
            });
            filterContainer.style.display = "block";
        }

        function toggleAllFilters(checked) {
            filterListDiv.querySelectorAll("input[type='checkbox']").forEach(cb => cb.checked = checked);
            updateScatterChart();
        }

        function updateScatterChart() {
            const checkboxes = filterListDiv.querySelectorAll("input[type='checkbox']:checked");
            const selectedParams = new Set(Array.from(checkboxes).map(cb => cb.value));
            let scatterPoints = [];
            const stationList = Object.keys(structuredData).sort();

            let foundQualities = new Set();

            stationList.forEach((station) => {
                const visits = structuredData[station];
                Object.keys(visits).forEach(date => {
                    const visitData = visits[date];
                    const matchedParamsRaw = visitData.params.filter(p => selectedParams.has(p));
                    const uniqueParams = new Set(matchedParamsRaw);
                    const count = uniqueParams.size;

                    if (count > 0) {
                        // Jitter logic: spread points across the "lane" (width 1, centered at integers)
                        // We want points between -0.4 and +0.4 relative to the station index.
                        const jitterX = (Math.random() - 0.5) * 0.8;
                        const jitterY = (Math.random() - 0.5) * 0.2;

                        let minQual = 999;
                        let hasValidQual = false;

                        uniqueParams.forEach(p => {
                            const q = visitData.qualities[p];
                            if (q !== undefined && q !== -1) {
                                if (q < minQual) minQual = q;
                                hasValidQual = true;
                            }
                        });

                        if (!hasValidQual) minQual = -1;
                        foundQualities.add(minQual);

                        const hasWarning = visitData.allSamplingIds && visitData.allSamplingIds.size > 1;

                        scatterPoints.push({
                            // Explicitly map Station to Index + Jitter.
                            // Since axis is linear, this places the point numerically.
                            x: stationList.indexOf(station) + jitterX,
                            y: count + jitterY,
                            rawStation: station, rawDate: date, rawCount: count,
                            rawParams: visitData.params, rawValues: visitData.values, rawLink: visitData.link,
                            rawMinQual: minQual,
                            hasWarning: hasWarning,
                            rawSamplingMap: visitData.samplingMap
                        });
                    }
                });
            });

            updateLegend(foundQualities);

            const width = Math.max(100, stationList.length * 50);
            document.getElementById('chartBox2').style.width = `${width}px`;
            const ctx = document.getElementById('chartParams').getContext('2d');
            if (chartParams) chartParams.destroy();

            chartParams = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Prøver',
                        data: scatterPoints,
                        backgroundColor: ctx => {
                            const q = ctx.raw?.rawMinQual;
                            return ksColors[q] || ksColors['-1'];
                        },
                        pointStyle: ctx => ctx.raw?.hasWarning ? 'triangle' : 'circle',
                        pointRadius: ctx => ctx.raw?.hasWarning ? 8 : 4,
                        pointHoverRadius: 8,
                        borderColor: ctx => ctx.raw?.hasWarning ? '#000' : 'transparent',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    onClick: (e) => {
                        const points = chartParams.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
                        if (points.length) showDetails(chartParams.data.datasets[0].data[points[0].index], selectedParams);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (ctx) => `${ctx[0].raw.rawStation} (${ctx[0].raw.rawDate})`,
                                label: (ctx) => {
                                    let txt = `Parametre: ${ctx.raw.rawCount} (Laveste KS: ${ctx.raw.rawMinQual})`;
                                    if (ctx.raw.hasWarning) txt += " [ADVARSEL: Flere prøvetagninger!]";
                                    return txt;
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(54,162,235,0.3)'
                                },
                                mode: 'xy',
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: -0.5,
                            max: stationList.length - 0.5,
                            ticks: {
                                stepSize: 0.5,
                                autoSkip: false,
                                maxRotation: 90,
                                minRotation: 45,
                                callback: function (value, index, values) {
                                    // Only show label for integers (Stations)
                                    if (value % 1 === 0) {
                                        const idx = Math.round(value);
                                        if (idx >= 0 && idx < stationList.length) {
                                            return stationList[idx];
                                        }
                                    }
                                    return ''; // Hide label for half-steps
                                }
                            },
                            grid: {
                                // Only show grid lines for half-steps (boundaries)
                                color: function (context) {
                                    if (context.tick.value % 1 !== 0) {
                                        return '#ddd'; // Visible grid at 0.5, 1.5
                                    }
                                    return 'transparent'; // Hidden grid at 0, 1 (center of lane)
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateLegend(foundQualitiesSet) {
            legendContainer.innerHTML = "";

            const sortedQuals = Array.from(foundQualitiesSet).sort((a, b) => a - b);

            sortedQuals.forEach(q => {
                const span = document.createElement("span");
                span.className = "legend-item";
                const color = ksColors[q] || ksColors['-1'];
                const label = q === -1 ? "Ukendt" : `KS niveau ${q}`;

                span.innerHTML = `<span class="legend-dot" style="background:${color}"></span> ${label}`;
                legendContainer.appendChild(span);
            });

            if (sortedQuals.length === 0) {
                legendContainer.innerHTML = "<small style='color:#999'>Ingen data vist</small>";
            }
        }

        function showDetails(point, selectedFilterSet) {
            detailsSection.style.display = 'block';
            detailsSection.scrollIntoView({ behavior: 'smooth' });

            let htmlInfo = `<b>Station:</b> ${point.rawStation} <br> <b>Dato:</b> ${point.rawDate}`;
            if (point.rawLink) htmlInfo += `<br><a href="${point.rawLink}" target="_blank" class="vanda-link">Åbn i Vanda</a>`;
            detailsInfo.innerHTML = htmlInfo;

            detailsTableBody.innerHTML = "";

            const uniqueParamsInSample = new Set(point.rawParams);
            const allFilters = Array.from(selectedFilterSet).sort();

            allFilters.forEach(paramName => {
                const tr = document.createElement('tr');
                const isPresent = uniqueParamsInSample.has(paramName);
                const val = isPresent && point.rawValues[paramName] !== undefined ? point.rawValues[paramName] : '-';

                let qual = '';
                let qualClass = '';

                if (isPresent) {
                    const qNum = structuredData[point.rawStation][point.rawDate].qualities[paramName];
                    if (qNum !== undefined && qNum !== -1) {
                        qual = qNum;
                        qualClass = `ks-${qNum} ks-cell`;
                    } else if (qNum === -1 || isNaN(qNum)) {
                        qual = '?';
                        qualClass = 'ks-unknown ks-cell';
                    }
                }

                // Hent alle ID'er hvis det er et Set, ellers streng
                let displaySamp = "";
                if (isPresent && point.rawSamplingMap && point.rawSamplingMap[paramName]) {
                    const valOrSet = point.rawSamplingMap[paramName];
                    if (valOrSet instanceof Set) {
                        displaySamp = Array.from(valOrSet).join(", ");
                    } else {
                        displaySamp = valOrSet;
                    }
                }

                tr.innerHTML = `
                <td>${paramName}</td>
                <td>${isPresent ? 'Fundet' : 'Mangler'}</td>
                <td>${val}</td>
                <td>${displaySamp}</td>
                <td class="${qualClass}">${qual}</td>
            `;
                detailsTableBody.appendChild(tr);
            });

            drawTimeSeries(point.rawStation, point.rawDate, selectedFilterSet);
        }

        function drawTimeSeries(stationName, selectedDate, selectedFilterSet) {
            const ctx = document.getElementById('chartTime').getContext('2d');
            if (chartTime) chartTime.destroy();

            const history = stationHistory[stationName] || [];
            const datasets = [];
            const activeParams = Array.from(selectedFilterSet);
            const colors = ['#0078d4', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6', '#34495e', '#e67e22'];

            activeParams.forEach((param, i) => {
                let measurements = history
                    .filter(m => m.param === param)
                    .map(m => { return { x: m.date, y: m.value }; });

                measurements.sort((a, b) => new Date(a.x) - new Date(b.x));

                if (measurements.length > 0) {
                    datasets.push({
                        label: param,
                        data: measurements,
                        borderColor: colors[i % colors.length],
                        backgroundColor: colors[i % colors.length],
                        tension: 0.1,
                        pointRadius: 4,
                        spanGaps: true
                    });
                }
            });

            chartTime = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        title: { display: true, text: `Historik for ${stationName}` },
                        zoom: {
                            zoom: {
                                drag: { enabled: true, backgroundColor: 'rgba(54,162,235,0.3)' },
                                mode: 'x'
                            }
                        },
                        annotation: {
                            annotations: {
                                line1: {
                                    type: 'line',
                                    xMin: selectedDate,
                                    xMax: selectedDate,
                                    borderColor: 'rgba(255, 0, 0, 0.8)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: { display: true, content: 'Valgt', position: 'start' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day', tooltipFormat: 'yyyy-MM-dd' },
                            title: { display: true, text: 'Dato' }
                        },
                        y: { title: { display: true, text: 'Resultat' } }
                    }
                }
            });
        }

        function resetZoomChart() {
            if (chartTime) chartTime.resetZoom();
        }
    </script>

</body>

</html>
